name: Build and push app/chart images

on:
  workflow_call:
    inputs:
      # ---- CDN (optional, opt-in) ----
      cdn_enabled:
        description: "Enable CDN URL rewrite + asset upload"
        required: false
        type: boolean
        default: false
      cdn_asset_exts:
        description: "Comma-separated list of asset extensions"
        required: false
        type: string
        default: ""   # we'll fall back to a global default
    secrets:
      ORG_HELM_CHART_UPDATER_ID:
        required: true
      ORG_HELM_CHART_UPDATER_PRIVATE_KEY:
        required: true
      CDN_SAS_TOKEN:
        required: false  # only needed when CDN is actually enabled
    outputs:
      app_version:
        description: "Computed app version from semantic-release"
        value: ${{ jobs.get-version.outputs.version }}
      app_image:
        description: "Base image repository for this app"
        value: ${{ jobs.get-version.outputs.image }}

permissions:
  contents: read

env:
  IMAGE_REPOSITORY: ghcr.io/${{ github.repository }}

  # Org-level CDN config (from org or repo variables)
  CDN_ACCOUNT_NAME: ${{ vars.CDN_ACCOUNT_NAME }}
  CDN_BASE_URL: ${{ vars.CDN_BASE_URL }}
  CDN_CONTAINER: ${{ vars.CDN_CONTAINER }}
  CDN_NAMESPACE: ${{ vars.CDN_NAMESPACE }}

  # Default asset extensions; can be overridden per-call via inputs.cdn_asset_exts
  CDN_ASSET_EXTS_DEFAULT: jpg,png,js,css,ico

jobs:

  # 1. Compute version & base image name
  get-version:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      image: ${{ steps.vars.outputs.image }}
      is_release: ${{ steps.vars.outputs.is_release }}
      version: ${{ steps.vars.outputs.version }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          lfs: true

      - name: Run Semantic Release
        id: semrel
        uses: docker://ghcr.io/bcit-ltc/semantic-release:sha-6ba64a5df332130d98182e3aee931ec84aa35604
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          plugins: |
            ['@semantic-release/commit-analyzer', '@semantic-release/release-notes-generator', '@semantic-release/github']

      - name: Compute version
        id: vars
        shell: bash
        run: |
          set -euo pipefail
          IMAGE="${IMAGE_REPOSITORY,,}"
          SHORT_SHA="${GITHUB_SHA::7}"
          TS="$(date -u +%Y%m%d%H%M%S)"

          # From semantic-release
          IS_RELEASE="${{ steps.semrel.outputs.new-release-published || 'false' }}"
          RELEASE_VERSION="${{ steps.semrel.outputs.release-version || '' }}"

          if [[ "${IS_RELEASE}" == "true" && -n "${RELEASE_VERSION}" ]]; then
            # On a real release, use the exact version determined by semantic-release.
            VERSION="${RELEASE_VERSION}"
          else
            # For RCs: base off the latest STABLE tag (vX.Y.Z), ignoring prereleases.
            RAW="$(git tag --list 'v[0-9]*.[0-9]*.[0-9]*' --sort=-v:refname | head -n1 || true)"
            BASE="${RAW#v}"
            [[ -z "${BASE}" ]] && BASE="0.0.0"

            IFS='.' read -r MAJ MIN PAT <<< "${BASE}"
            NEXT_BASE="${MAJ}.${MIN}.$((PAT+1))"

            # RC format ensures SemVer precedence by timestamp, then short SHA for traceability.
            VERSION="${NEXT_BASE}-rc.${TS}.${SHORT_SHA}"
          fi

          {
            echo "image=${IMAGE}"
            echo "is_release=${IS_RELEASE}"
            echo "version=${VERSION}"
          } | tee -a "$GITHUB_OUTPUT"

  # 2. Build image, optional CDN rewrite/upload, push & sign
  build-app-image:
    runs-on: ubuntu-latest
    needs: get-version
    permissions:
      contents: read
      packages: write
      id-token: write
    env:
      IS_RELEASE: ${{ needs.get-version.outputs.is_release }}
      APP_VERSION: ${{ needs.get-version.outputs.version }}
      IMAGE: ${{ needs.get-version.outputs.image }}

      # If caller provided cdn_asset_exts, use it; else use default
      ASSET_EXTS: ${{ inputs.cdn_asset_exts }}
    outputs:
      tags: ${{ steps.meta.outputs.tags }}
    steps:
      - uses: actions/checkout@v4

      - name: Write VERSION file for build
        run: echo "${APP_VERSION}" > VERSION

      - uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - uses: docker/setup-buildx-action@v3

      - name: Generate container metadata
        id: meta
        uses: docker/metadata-action@9ec57ed1fcdbf14dcef7dfbe97b2010124a938b7
        env:
          DOCKER_METADATA_ANNOTATIONS_LEVELS: manifest,index
        with:
          images: ${{ env.IMAGE }}
          tags: |
            type=raw,value=${{ env.APP_VERSION }}
            type=semver,pattern={{major}}.{{minor}},enable=${{ env.IS_RELEASE == 'true' }}
            type=raw,value=stable,enable=${{ env.IS_RELEASE == 'true' }}
          flavor: |
            latest=true

      - name: Build image (no push, load into local Docker)
        id: build
        env:
          DOCKER_BUILD_RECORD_UPLOAD: false
          DOCKER_BUILD_SUMMARY: false
        uses: docker/build-push-action@v6
        with:
          context: .
          push: false
          load: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          annotations: ${{ steps.meta.outputs.annotations }}
          provenance: false
          sbom: false
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # ---- CDN steps ----
      - name: Validate CDN configuration
        if: ${{ inputs.cdn_enabled }}
        shell: bash
        run: |
          set -euo pipefail

          if [[ -z "${CDN_ACCOUNT_NAME:-}" || -z "${CDN_CONTAINER:-}" || -z "${CDN_BASE_URL:-}" || -z "${CDN_NAMESPACE:-}" ]]; then
            echo "CDN is enabled but one or more CDN_* vars are missing."
            echo "CDN_ACCOUNT_NAME=${CDN_ACCOUNT_NAME:-<empty>}"
            echo "CDN_CONTAINER=${CDN_CONTAINER:-<empty>}"
            echo "CDN_BASE_URL=${CDN_BASE_URL:-<empty>}"
            echo "CDN_NAMESPACE=${CDN_NAMESPACE:-<empty>}"
            echo "Skipping CDN rewrite/upload."
            exit 0
          fi

          if [[ -z "${ASSET_EXTS:-}" ]]; then
            echo "ASSET_EXTS is empty; using default ${CDN_ASSET_EXTS_DEFAULT}"
            echo "ASSET_EXTS=${CDN_ASSET_EXTS_DEFAULT}" >> "$GITHUB_ENV"
          fi

      - name: Show local image
        if: ${{ inputs.cdn_enabled }}
        shell: bash
        run: |
          set -euo pipefail
          echo "Local images for ${IMAGE}:"
          docker images "${IMAGE}"

      - name: Extract static files from runtime image
        if: ${{ inputs.cdn_enabled }}
        shell: bash
        run: |
          set -euo pipefail

          RUNTIME_STATIC_ROOT="/usr/share/nginx/html"

          CID="$(docker create "${IMAGE}:${APP_VERSION}")"
          mkdir -p site
          docker cp "${CID}:${RUNTIME_STATIC_ROOT}/." site
          echo "Extracted static files from ${RUNTIME_STATIC_ROOT} into ./site"
          ls -R site || true

          echo "CID=${CID}" >> "$GITHUB_ENV"

      - name: Compute CDN asset version
        if: ${{ inputs.cdn_enabled }}
        id: cdn_asset_version
        shell: bash
        env:
          ASSET_EXTS: ${{ env.ASSET_EXTS }}
        run: |
          set -euo pipefail

          SRC_DIR="site"
          ASSET_EXTS="${ASSET_EXTS}"

          echo "Using asset extensions for versioning: ${ASSET_EXTS}"

          FIND_EXPR=""
          OLD_IFS="$IFS"
          IFS=','
          for ext in $ASSET_EXTS; do
            ext_trim="$(printf '%s' "$ext" | xargs)"
            [ -z "${ext_trim}" ] && continue
            if [ -z "${FIND_EXPR}" ]; then
              FIND_EXPR="-name '*.${ext_trim}'"
            else
              FIND_EXPR="${FIND_EXPR} -o -name '*.${ext_trim}'"
            fi
          done
          IFS="$OLD_IFS"

          if [ -z "${FIND_EXPR}" ]; then
            echo "No valid asset extensions in ASSET_EXTS; using fallback CDN asset version." >&2
            VERSION="noassets000000"
            echo "cdn_asset_version=${VERSION}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          ASSET_FILES="$(
            eval "find \"${SRC_DIR}\" -type f \\( ${FIND_EXPR} \\) -print0" | tr '\0' '\n' || true
          )"

          if [ -z "${ASSET_FILES}" ]; then
            echo "No matching asset files in ${SRC_DIR}; using fallback CDN asset version." >&2
            VERSION="noassets000000"
            echo "cdn_asset_version=${VERSION}" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          HASH="$(
            eval "find \"${SRC_DIR}\" -type f \\( ${FIND_EXPR} \\) -print0" \
              | sort -z \
              | xargs -0 sha256sum \
              | sha256sum \
              | cut -c1-12
          )"

          echo "Computed CDN asset version from assets: ${HASH}"
          echo "cdn_asset_version=${HASH}" >> "$GITHUB_OUTPUT"

      - name: Rewrite HTML asset URLs for CDN (Perl-based, in extracted site)
        if: ${{ inputs.cdn_enabled }}
        shell: bash
        env:
          CDN_ASSET_VERSION: ${{ steps.cdn_asset_version.outputs.cdn_asset_version }}
          CDN_BASE_URL: ${{ env.CDN_BASE_URL }}
          CDN_CONTAINER: ${{ env.CDN_CONTAINER }}
          CDN_NAMESPACE: ${{ env.CDN_NAMESPACE }}
          ASSET_EXTS: ${{ env.ASSET_EXTS }}
        run: |
          set -euo pipefail

          if [ -z "${CDN_ASSET_VERSION}" ]; then
            echo "CDN_ASSET_VERSION is empty; skipping rewrite." >&2
            exit 0
          fi

          if [ -z "${CDN_BASE_URL}" ] || [ -z "${CDN_CONTAINER}" ]; then
            echo "CDN_BASE_URL or CDN_CONTAINER is not set; skipping rewrite." >&2
            exit 0
          fi

          APP_NAME="${{ github.event.repository.name }}"
          CDN_PREFIX="${CDN_BASE_URL%/}/${CDN_CONTAINER}/${CDN_NAMESPACE}/${APP_NAME}/${CDN_ASSET_VERSION}"

          EXT_PATTERN="$(printf '%s' "${ASSET_EXTS}" | tr -d '[:space:]' | sed 's/,/|/g')"

          if [ -z "${EXT_PATTERN}" ]; then
            echo "No valid extensions in ASSET_EXTS; skipping rewrite." >&2
            exit 0
          fi

          echo "Rewriting HTML assets to CDN prefix: ${CDN_PREFIX}"
          echo "Matching extensions: ${ASSET_EXTS}"

          export CDN_PREFIX EXT_PATTERN

          # For each HTML file, rewrite asset URLs to use the CDN prefix if they match the configured extensions
          find site -type f -name '*.html' -print0 |
            while IFS= read -r -d '' f; do
              perl -0pi -e '
                my $cdn  = $ENV{CDN_PREFIX}  // "";
                my $exts = $ENV{EXT_PATTERN} // "";
                exit 0 unless $cdn && $exts;

                my $pat = qr{(src|href|data-src)=(["\x27])([^"\x27]+\.($exts)(?:[#?][^"\x27]*)?)\2}i;

                s{$pat}{
                  my ($attr, $q, $path) = ($1, $2, $3);

                  if ($path =~ m{^(?:[a-zA-Z][a-zA-Z0-9+.+-]*:|//)}) {
                    "$attr=$q$path$q";
                  } else {
                    my $p = $path;

                    $p =~ s{^\./}{};
                    $p =~ s{^/+}{};
                    $p =~ s{^(?:\.\./)+}{};

                    "$attr=$q$cdn/$p$q";
                  }
                }eg;
              ' "$f"
            done

      - name: Copy rewritten site back into container and commit
        if: ${{ inputs.cdn_enabled }}
        shell: bash
        env:
          CID: ${{ env.CID }}
        run: |
          set -euo pipefail
          if [ -z "${CID:-}" ]; then
            echo "No container ID found; cannot commit rewritten site." >&2
            exit 1
          fi

          RUNTIME_STATIC_ROOT="/usr/share/nginx/html"

          echo "Copying rewritten site back into container ${CID}:${RUNTIME_STATIC_ROOT}"
          docker cp site/. "${CID}:${RUNTIME_STATIC_ROOT}"

          echo "Committing container ${CID} to ${IMAGE}:${APP_VERSION}"
          docker commit "${CID}" "${IMAGE}:${APP_VERSION}"

          docker rm "${CID}"

      - name: Upload assets to CDN
        if: ${{ inputs.cdn_enabled }}
        uses: azure/CLI@v2
        env:
          SAS_TOKEN: ${{ secrets.CDN_SAS_TOKEN }}
          CDN_ACCOUNT_NAME: ${{ env.CDN_ACCOUNT_NAME }}
          CDN_CONTAINER: ${{ env.CDN_CONTAINER }}
          CDN_NAMESPACE: ${{ env.CDN_NAMESPACE }}
          CDN_ASSET_VERSION: ${{ steps.cdn_asset_version.outputs.cdn_asset_version }}
          ASSET_EXTS: ${{ env.ASSET_EXTS }}
        with:
          inlineScript: |
            set -euo pipefail

            if [ -z "${SAS_TOKEN:-}" ] || [ -z "${CDN_ACCOUNT_NAME:-}" ] || [ -z "${CDN_CONTAINER:-}" ]; then
              echo "CDN upload config incomplete (missing SAS_TOKEN/CDN_ACCOUNT_NAME/CDN_CONTAINER); skipping upload."
              exit 0
            fi

            SRC_DIR="site"
            if [ ! -d "${SRC_DIR}" ]; then
              echo "No site dir ${SRC_DIR}; nothing to upload." >&2
              exit 0
            fi

            CDN_NAMESPACE="${CDN_NAMESPACE}"
            APP_NAME="${{ github.event.repository.name }}"
            CDN_ASSET_VERSION="${CDN_ASSET_VERSION}"
            ASSET_EXTS="${ASSET_EXTS}"

            PREFIX="${CDN_NAMESPACE}/${APP_NAME}/${CDN_ASSET_VERSION}"

            echo "Checking if assets already exist at prefix ${PREFIX}..."

            # If any blob exists under this prefix, assume this version has already been uploaded.
            EXISTING_COUNT="$(
              az storage blob list \
                --account-name "${CDN_ACCOUNT_NAME}" \
                --sas-token "${SAS_TOKEN}" \
                --container-name "${CDN_CONTAINER}" \
                --prefix "${PREFIX}/" \
                --num-results 1 \
                --query "length(@)" \
                -o tsv
            )"

            if [ "${EXISTING_COUNT:-0}" != "0" ]; then
              echo "Assets for prefix ${PREFIX} already exist (${EXISTING_COUNT}+ blob). Skipping upload."
              exit 0
            fi

            echo "Uploading assets from ${SRC_DIR} to container ${CDN_CONTAINER} at prefix ${PREFIX}"
            echo "Using asset extensions: ${ASSET_EXTS}"

            OLD_IFS="$IFS"
            IFS=','
            for ext in $ASSET_EXTS; do
              ext_trim="$(printf '%s' "$ext" | xargs)"
              [ -z "${ext_trim}" ] && continue
              pattern="*.${ext_trim}"
              echo "  - Uploading assets matching pattern: ${pattern}"
              az storage blob upload-batch \
                --account-name "${CDN_ACCOUNT_NAME}" \
                --sas-token "${SAS_TOKEN}" \
                --destination "${CDN_CONTAINER}" \
                --destination-path "${PREFIX}" \
                --source "${SRC_DIR}" \
                --pattern "${pattern}" \
                --overwrite true \
                --content-cache-control "public, max-age=31536000, immutable"
            done
            IFS="$OLD_IFS"
            echo "CDN upload complete."

      # ---- Push & sign ----
      - name: Push all tags
        shell: bash
        env:
          IMAGE_TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          echo "Image tags to push:"
          printf '%s\n' ${IMAGE_TAGS}
          for tag in ${IMAGE_TAGS}; do
            echo "Pushing ${tag}"
            docker push "${tag}"
          done

      - uses: sigstore/cosign-installer@v3

      - name: Cosign sign by tag
        shell: bash
        env:
          IMAGE_TAGS: ${{ steps.meta.outputs.tags }}
        run: |
          set -euo pipefail
          for tag in ${IMAGE_TAGS}; do
            echo "Signing ${tag}"
            cosign sign --yes "${tag}"
          done

  # 3. Trigger helm-charts repo remote-bump workflow to update chart version
  dispatch-helm-charts:
    runs-on: ubuntu-latest
    needs: [build-app-image, get-version]
    if: ${{ needs.get-version.outputs.version != '' }}
    steps:

      # Generate token to trigger remote workflow
      - id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ secrets.ORG_HELM_CHART_UPDATER_ID }}
          private-key: ${{ secrets.ORG_HELM_CHART_UPDATER_PRIVATE_KEY }}
          owner: ${{ github.repository_owner }}
          repositories: helm-charts
          permission-actions: write
          permission-contents: read

      - name: Trigger `helm-charts` repo remote-bump
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          CHART: ${{ github.event.repository.name }}
          VER: ${{ needs.get-version.outputs.version }}
        run: |
          set -euo pipefail
          gh workflow run remote-bump.yaml \
            -R bcit-ltc/helm-charts \
            -r main \
            -f chart_name="$CHART" \
            -f version="$VER"
          echo "Dispatched remote-bump.yaml for ${CHART} -> ${VER}"
